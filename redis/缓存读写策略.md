# 三种常用的缓存读写策略

## Cache Aside Pattern（旁路缓存模式）

> 比较常用的缓存读写模式，适用于读请求较多的场景

写：

+ 先更新DB
+ 然后直接删除cache

读：

+ 从cache中读取数据，读到就直接返回
+ cache中读取不到的话，就从DB中读取数据返回
+ 再把数据放到cache中

### 写数据过程中，可以先删除cache，再更新db吗？

不行，这样会造成db与cache数据不一致的问题。

> 请求1把cache中的A数据删除 -> 请求2从DB中读取数据 -> 请求1再把db中的A数据更新

### 写数据过程中，先更新db后删除cache？

理论上可能会出现数据不一致行的问题，但是概率很低，因为缓存的写入速度比db的写出速度快很多

> 请求1先读数据A，请求2随后写数据A，并且数据A不在缓存中的话也有可能产生数据不一致性的问题。

缺陷1：首次请求数据一定不在cache的问题？
  + 解决方法：将热点数据提前放入cache中

缺陷2：写操作比较频繁的话会导致cache中的数据会频繁被删除，会影响缓存命中率？
  + 解决方法：
  + 数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。
  + 可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。

缺陷3: 如何保证两个操作都能执行成功？
  1. 消息队列重试机制，将第二个操作要操作的数据放入消息队列中，由消费者来操作数据。
     + 如果删除缓存失败，可以从消息队列中重新读取数据，然后删除缓存，这个就是重试机制。
     + 如果删除成功，就从队列中移除掉这个数据，避免重复操作。
  2. 订阅MySQL的bin log，再操作缓存，先更新db第一步就是操作数据库，当操作完成后将会有一条binlog的数据，我们只需要订阅这条binlog日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴的Canal中间件就是基于这个来实现的。
  

缺陷4: 先删除cache，再删除db如何保证一致性？
  + 延迟双删（添加一个睡眠的时间，为了确保再请求A睡眠的时候，请求B能从数据库中读取数据再写入缓存）

## Read/Write Through Pattern（读写穿透）

Read/Write Through Pattern中服务端把cache视为主要数据存储，从中读取数据并将数据写入其中。cache负责将此数据读取和写入db，从而减轻了应用程序的职责。

> redis并没有提供cache将数据写入db的功能

写(Write Through)：

+ 先查cache，cache中不存在，直接更新db
+ cache中存在，则先更新cache，然后cache服务自己更新db（同步更新cache和db）

读(Read Through):

+ 从cache中读取数据，读取到就直接返回
+ 读取不到的话就先从db加载，写入cache后返回响应

## Write Behind Pattern（异步缓存写入）

异步缓存写入与读写穿透都是cache服务来负责cache和db的写入。

读写穿透是同步更新cache和db，而异步缓存只是更新缓存，不直接更新db，而是改为异步批量的方式来更新db。

开发中较为少见，在消息队列中的消息异步写入磁盘、MySQL的InnoDB Buffer Pool机制都用到了这种策略。

写性能非常高，适合一些数据经常变化但又对数据一致性要求没有那么高的场景，比如浏览量、点赞数。

## 缓存穿透：数据不存在也不再数据库

+ 使用布隆过滤器判断数据是否存在，避免通过查询数据库来判断
> 布隆过滤器：
> 1. 使用N个哈希函数分别对数据进行哈希计算，得到N个哈希值
> 2. 将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置
> 3. 将每个哈希值在位图数组的对应位置的值设置为 1

## 缓存雪崩：大量缓存过期，redis故障

> 当大量数据请求到数据库的时候，导致数据库压力骤增，从而导致系统崩溃

+ 解决大量缓存过期：
    + 均匀设计缓存过期时间：给数据的过期时间设置一个随机数
    + 设置互斥锁：如果发现访问的数据不在缓存中，就加一个互斥锁，保证同一时间内只有一个请求来构建缓存。
+ 后台更新缓存
  + 将更新缓存的工作交由后台线程来进行定时更新
  + 频繁的检测缓存是否有效；通过消息队列通知后台进行更新缓存，缓存预热
+ redis 宕机如何解决：
  + 服务熔断或请求限流：直接返回错误不请求到数据库/只允许少部分请求到数据库，其余的进行错误返回
  + 构建高可用的redis集群，使用主从节点构建redis高可用缓存

## 缓存击穿：热点数据缓存过期

> 当有几个业务被频繁的请求，比如秒杀，热点数据，与雪崩类似