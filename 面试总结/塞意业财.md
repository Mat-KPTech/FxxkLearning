# 1. 说一下印象深刻的系统



# 2. 如何保证你的系统出入库不会出现负库存的现象

+ 悲观锁：即查询某条数据时，让数据库为该条记录加锁，锁住后无法操作

  > select for update

+ 乐观锁：在更新时判断此时库存是否是之前查询出来的库存，如果相同表示没人修改，可以更新库存，否则表示别人抢过资源，不进行库存操作。

  > 使用乐观锁需要修改数据库的事务隔离级别：Read commited

+ 分段执行的排队：

**将提交操作分成两段式** 

 1. 第一阶段进行申请，申请预减库存，申请成功后，进入消息队列；

    > 从db前移到redis中，所以的预减库存的操作都放在内存中，由于redis不存在锁所以不会出现互相等待，并且由于redis的写性能和读性能都比db要高，也就解决了高并发下的性能问题。

 2. 第二阶段进行确认，从消息队列中申请令牌，然后完成下单操作。查库存 ->  创建订单 -> 扣减库存。通过分布式锁来保障多个provider实例并发下单产生超卖的问题

    > 通过队列等异步手段，将变化的数据异步写入到db中
    > 引入队列，按照次序更新到DB，串行处理，当达到库存阈值就不在消费队列，并且关闭接下来的功能，也就解决了超卖的问题

# 3. 加锁是怎么实现的
# 4. 你的系统金额是使用什么数据库字段类型的，oracle用什么，mssql用什么

    oracle使用number，mssql使用money，mysql使用decimal，但是decimal是字符类型，如果数据量大的时候可以使用int，然后再程序中乘相应的倍数

# 5. 为什么不用float

# 6. 说一下java的线程池
# 7. 为什么实体类必须重写equals和hashcode

    hashcode和equals是用来协同判断两个对象是否相等的，采用这种方式的原因是可以提高程序插入和查询的速度，如果在重写equals的时候，不重写hashcode，
    就会导致在某些情况出现程序执行的异常。

# 8. AOP的两种实现方式
# 9. 说一下CGLIB
# 10. 说一下对秒杀系统的设计
# 11. 你了解springboot吗？怎么写一个starter？

    写一个auto configuration类➕一个缺省的配置类

# 12. Spring Cloud Nacos和Eureka跟Consoul的区别
# 13. Nacos符合了CAP的什么原则
# 14. 说一下java的引用方式

    强引用：比如new一个对象，即使java在进行gc回收时也不会回收该对象
    软引用：一般不会轻易回收，只有当jvm内存不够的情况下才会进行回收，主要是用来缓存服务器中间计算结果及不需要实时保存的用户行为
    弱引用：一旦垃圾回收已经启动发现了它，就会回收
    虚引用：不能单独存在，必须和引用队列联合使用，主要作用是跟踪对象被回收的状态

# 15. redis的几种常用类型

    常用有五种基本类型：String（字符串），Hash（哈希），List（列表），Set（集合），Zset（有序集合）
    新增4种类型：BitMap，HyperLogLog，GEO，Stream。

# 16. 平时用redis来做什么（使用redis的场景）

    老5样应用场景：
    String：缓存对象、常规计数、分布式锁、共享 session 信息等
    List：消息队列
    Hash：缓存对象、购物车等
    Set：聚合计算场景，点赞，共同关注，抽奖等
    Zset：排序场景，排行榜，电话和姓名排序等

    新4样应用场景：
    BitMap：二值状态统计的场景，比如签到，判断登陆状态、连续签到用户总数等
    HyperLogLog：海量数据基数统计的场景，比如百万级网页 UV 计数等
    GEO：gis存储地理位置的场景，比如滴滴打车
    Stream：消息队列，相比较基于List的类型的消息队列，自动生成全局唯一消息ID，支持以消费组形式消费数据

# 17. redis缓存击穿，缓存穿透的解决方案

+ 缓存雪崩：所有的key的失效时间都是12小时，中午12点刷新，但是0点的时候有一个什么活动的有大量的用户涌进来，假设当时每秒有6000个请求，缓存可以抗住每秒5000的请求，但是缓存当时的key都失效了，6000个请求全部打入到数据库中，dba就挂了，然后我们重启数据库，立马又被新的流量给打死 了，值就是我的理解的缓存血崩。

  > 批量往redis存数据的时候，把每个key的失效时间都设置一个随机值，保证数据不会在同一时间失效。或者设置热点数据缓存永不过期，有更新操作的时候刷新缓存。

+ 缓存穿透：指缓存和数据库中都没有数据，而用户不断发起请求

  > 在接口层新增校验，比如用户鉴权，参数做校验，不合法的直接就return掉，还有redis里面有**布隆过滤器**可以防止缓存穿透的发生，判断key是否在数据库中存在，不存在的话直接return，存在就插db刷新key value再return

+ 缓存击穿：缓存击穿是指一个key非常热点，在不断的扛着大并发，大并发集中对一个点进行访问，当这个key在失效的瞬间，持续大的并发就会击穿缓存，直接请求数据库

  > 设置热点数据永不过期或者加上互斥锁就可以搞定。

# 18. 索引失效的场景
1. 使用左模糊模糊或左右模糊匹配的时候都会造成索引失效
2. 

# 19.Spring注入的实现方式

